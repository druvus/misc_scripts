import argparse
import csv
import logging
import sys
from typing import List, Dict

def setup_logging(level: str) -> None:
    """
    Configure the logging settings.

    Args:
        level (str): Logging level as a string (e.g., 'DEBUG', 'INFO').
    """
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
        print(f"Invalid log level: {level}")
        sys.exit(1)
    logging.basicConfig(
        level=numeric_level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

def parse_arguments() -> argparse.Namespace:
    """
    Parse command-line arguments.

    Returns:
        argparse.Namespace: Parsed arguments.
    """
    parser = argparse.ArgumentParser(
        description="Process species assemblies to generate output directories and assembly information."
    )
    parser.add_argument(
        '-i', '--input',
        type=str,
        required=True,
        help='Path to the input CSV file generated by the previous script.'
    )
    parser.add_argument(
        '-o', '--output',
        type=str,
        required=True,
        help='Path to the output file.'
    )
    parser.add_argument(
        '-p', '--prefix',
        type=str,
        required=True,
        help='Prefix to be combined with species names to form the output directory.'
    )
    parser.add_argument(
        '-l', '--log_level',
        type=str,
        default='INFO',
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
        help='Set the logging level. Default is INFO.'
    )
    return parser.parse_args()

def read_input_file(file_path: str) -> List[Dict[str, str]]:
    """
    Read the input CSV file and return a list of dictionaries.

    Args:
        file_path (str): Path to the input CSV file.

    Returns:
        List[Dict[str, str]]: List of dictionaries representing each row.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            data = [row for row in reader]
        logging.debug(f"Read {len(data)} rows from {file_path}")
        return data
    except FileNotFoundError:
        logging.error(f"Input file not found: {file_path}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading input file '{file_path}': {e}")
        sys.exit(1)

def process_species_data(data: List[Dict[str, str]], prefix: str) -> List[Dict[str, str]]:
    """
    Process the species data to generate output directories and assemble required information.

    Args:
        data (List[Dict[str, str]]): List of dictionaries containing species data.
        prefix (str): Prefix to be used for output directories.

    Returns:
        List[Dict[str, str]]: Processed data with 'outdir', 'assembly_name', and 'assembly_accession'.
    """
    processed_data = []
    for idx, row in enumerate(data, start=1):
        species_name = row.get('Species Name', '').strip()
        assembly_name = row.get('Assembly Name', '').strip()
        assembly_accession = row.get('GenBank Accession', '').strip()

        if not species_name:
            logging.warning(f"Row {idx} is missing 'Species Name'. Skipping.")
            continue

        if not assembly_name or assembly_name == 'Not Available':
            logging.warning(f"Species '{species_name}' does not have an assembly name. Skipping.")
            continue

        if not assembly_accession or assembly_accession == 'Not Available':
            logging.warning(f"Species '{species_name}' does not have an assembly accession. Skipping.")
            continue

        species_dir = species_name.replace(' ', '_')
        outdir = f"{prefix}/{species_dir}"

        processed_data.append({
            'outdir': outdir,
            'assembly_name': assembly_name,
            'assembly_accession': assembly_accession
        })
        logging.debug(f"Processed species '{species_name}': outdir='{outdir}', "
                      f"assembly_name='{assembly_name}', assembly_accession='{assembly_accession}'")
    return processed_data

def write_output_file(file_path: str, data: List[Dict[str, str]]) -> None:
    """
    Write the processed data to the output file.

    Args:
        file_path (str): Path to the output file.
        data (List[Dict[str, str]]): List of dictionaries to write.
    """
    try:
        with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ['outdir', 'assembly_name', 'assembly_accession']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for row in data:
                writer.writerow(row)
        logging.info(f"Data successfully written to {file_path}")
    except Exception as e:
        logging.error(f"Error writing to output file '{file_path}': {e}")
        sys.exit(1)

def main() -> None:
    """
    Main function to execute the processing of species assemblies.
    """
    args = parse_arguments()
    setup_logging(args.log_level)

    input_data = read_input_file(args.input)
    processed_data = process_species_data(input_data, args.prefix)
    write_output_file(args.output, processed_data)
    logging.info("Processing complete.")

if __name__ == "__main__":
    main()

